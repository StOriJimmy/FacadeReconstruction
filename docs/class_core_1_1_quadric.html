<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FacadeReconstruction: Core::Quadric Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FacadeReconstruction
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_core.html">Core</a></li><li class="navelem"><a class="el" href="class_core_1_1_quadric.html">Quadric</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_core_1_1_quadric-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Core::Quadric Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class representing a quadric. This class was written for fitting a quadric to a noisy point cloud with a Bayesian prior. The problem was that when there is missing data, using a standard fit can produce an unwanted surface, such as a hyperboloid. If there is some extra knowledge indicating the type of quadric that the fit should be, one can tune the prior to encourage the surface to take on a particular type. There are more details in the paper, <a href="http://link.springer.com/article/10.1007/s41095-016-0041-9">"Fitting quadrics with a Bayesian prior" - Daniel Beale et al. Journal of Computational Visual Media, 2016.</a>  
 <a href="class_core_1_1_quadric.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_quadric_8h_source.html">Quadric.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_core_1_1_quadric_1_1_fast_data_store.html">FastDataStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct provides an internal datastore for the quadric fitting algorithm, when fitting multiple quadrics points. It is pre-allocated to avoid uneccessary allocation on the heap (since the Eigen matrices are dynamic).  <a href="struct_core_1_1_quadric_1_1_fast_data_store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric_1_1_parameters.html">Parameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class containing the parameters of the quadric.  <a href="class_core_1_1_quadric_1_1_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a155c9f57ecf98b6af94251e409317079"><td class="memItemLeft" align="right" valign="top"><a id="a155c9f57ecf98b6af94251e409317079"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric.html#a155c9f57ecf98b6af94251e409317079">Quadric</a> ()</td></tr>
<tr class="memdesc:a155c9f57ecf98b6af94251e409317079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty quadric. <br /></td></tr>
<tr class="separator:a155c9f57ecf98b6af94251e409317079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d6d72c76af8e6022ad9d338e182e6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric.html#ac5d6d72c76af8e6022ad9d338e182e6a">Quadric</a> (const double *data, const uint32_t N, const double sigma)</td></tr>
<tr class="memdesc:ac5d6d72c76af8e6022ad9d338e182e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a quadric given a data matrix. The parameters will be estimated on construction.  <a href="#ac5d6d72c76af8e6022ad9d338e182e6a">More...</a><br /></td></tr>
<tr class="separator:ac5d6d72c76af8e6022ad9d338e182e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468854059b6634147b5fb0467aae3405"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric.html#a468854059b6634147b5fb0467aae3405">Quadric</a> (const <a class="el" href="class_core_1_1_quadric_1_1_parameters.html">Parameters</a> &amp;params)</td></tr>
<tr class="memdesc:a468854059b6634147b5fb0467aae3405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a quadric from the known parameters.  <a href="#a468854059b6634147b5fb0467aae3405">More...</a><br /></td></tr>
<tr class="separator:a468854059b6634147b5fb0467aae3405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bd8c7f36790b182523bfc47d8499ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_core_1_1_quadric_1_1_parameters.html">Parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric.html#a61bd8c7f36790b182523bfc47d8499ea">GetParameters</a> () const</td></tr>
<tr class="memdesc:a61bd8c7f36790b182523bfc47d8499ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parameters of the quadric.  <a href="#a61bd8c7f36790b182523bfc47d8499ea">More...</a><br /></td></tr>
<tr class="separator:a61bd8c7f36790b182523bfc47d8499ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9120966a0fb65b0fa85ebe6189bb0a2e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric.html#a9120966a0fb65b0fa85ebe6189bb0a2e">Fit</a> (const double *data, const uint32_t N, const double sigma)</td></tr>
<tr class="memdesc:a9120966a0fb65b0fa85ebe6189bb0a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit the quadric to a data matrix.  <a href="#a9120966a0fb65b0fa85ebe6189bb0a2e">More...</a><br /></td></tr>
<tr class="separator:a9120966a0fb65b0fa85ebe6189bb0a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31468022b562cd72e0a1d7fbf1ad9c07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric.html#a31468022b562cd72e0a1d7fbf1ad9c07">FitFast</a> (const double *data, const uint32_t N, const double sigma, <a class="el" href="struct_core_1_1_quadric_1_1_fast_data_store.html">FastDataStore</a> *fds)</td></tr>
<tr class="memdesc:a31468022b562cd72e0a1d7fbf1ad9c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit the quadric to a data matrix given a pre allocated <a class="el" href="struct_core_1_1_quadric_1_1_fast_data_store.html" title="This struct provides an internal datastore for the quadric fitting algorithm, when fitting multiple q...">FastDataStore</a>. In order to execute this method, one would do the following,.  <a href="#a31468022b562cd72e0a1d7fbf1ad9c07">More...</a><br /></td></tr>
<tr class="separator:a31468022b562cd72e0a1d7fbf1ad9c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2cc7b7d74b9b1b9d033bc1629702df"><td class="memItemLeft" align="right" valign="top">VerticesFaces&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric.html#afb2cc7b7d74b9b1b9d033bc1629702df">GetMeshRep</a> (const uint32_t N, const double *data, const uint32_t NPts) const</td></tr>
<tr class="memdesc:afb2cc7b7d74b9b1b9d033bc1629702df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mesh representing the quadric. The method takes a canonical surface such as an Ellipsoid and transforms it using the parameters of the quadric. Only an Ellipsoid has been implemented for demonstration purposes.  <a href="#afb2cc7b7d74b9b1b9d033bc1629702df">More...</a><br /></td></tr>
<tr class="separator:afb2cc7b7d74b9b1b9d033bc1629702df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2032f964cbb4b61c761488e3915f57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric.html#a1c2032f964cbb4b61c761488e3915f57">GetBoundedMeshRep</a> (VerticesFaces &amp;vf, const double *data, const uint32_t N) const</td></tr>
<tr class="memdesc:a1c2032f964cbb4b61c761488e3915f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a bounded mesh representing the quadric. The method takes a canonical surface such as an Ellipsoid and transforms it using the parameters of the quadric. Only an Ellipsoid has been implemented for demonstration purposes. The mesh is then truncated so that the vertices on the input point cloud do not fall outside the mesh.  <a href="#a1c2032f964cbb4b61c761488e3915f57">More...</a><br /></td></tr>
<tr class="separator:a1c2032f964cbb4b61c761488e3915f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d0f5023937bbc0ce1066d528fa2f2b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric.html#ab5d0f5023937bbc0ce1066d528fa2f2b">GetPointCloudBounds</a> (const uint32_t StartN, const double *data, const uint32_t N) const</td></tr>
<tr class="memdesc:ab5d0f5023937bbc0ce1066d528fa2f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of booleans indicating which points on the generated mesh are outside the maximum and minimum point cloud bounds.  <a href="#ab5d0f5023937bbc0ce1066d528fa2f2b">More...</a><br /></td></tr>
<tr class="separator:ab5d0f5023937bbc0ce1066d528fa2f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7060ecec0b047e7e3abb419c7f2afb6a"><td class="memItemLeft" align="right" valign="top">VerticesFaces&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_quadric.html#a7060ecec0b047e7e3abb419c7f2afb6a">GetPrincipleCylinder</a> (const uint32_t N, const double *data, const uint32_t NPts) const</td></tr>
<tr class="memdesc:a7060ecec0b047e7e3abb419c7f2afb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vertices and faces of the quadric, assuming that it is a cylinder. For a quadric cylinder one of the eigenvalues of the parameter A will be zero.  <a href="#a7060ecec0b047e7e3abb419c7f2afb6a">More...</a><br /></td></tr>
<tr class="separator:a7060ecec0b047e7e3abb419c7f2afb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class representing a quadric. This class was written for fitting a quadric to a noisy point cloud with a Bayesian prior. The problem was that when there is missing data, using a standard fit can produce an unwanted surface, such as a hyperboloid. If there is some extra knowledge indicating the type of quadric that the fit should be, one can tune the prior to encourage the surface to take on a particular type. There are more details in the paper, <a href="http://link.springer.com/article/10.1007/s41095-016-0041-9">"Fitting quadrics with a Bayesian prior" - Daniel Beale et al. Journal of Computational Visual Media, 2016.</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac5d6d72c76af8e6022ad9d338e182e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d6d72c76af8e6022ad9d338e182e6a">&#9670;&nbsp;</a></span>Quadric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Core::Quadric::Quadric </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a quadric given a data matrix. The parameters will be estimated on construction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the first element of a column major contiguous array of size 3N </td></tr>
    <tr><td class="paramname">N</td><td>the number of columns, or datapoints. </td></tr>
    <tr><td class="paramname">sigma</td><td>The hyper parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a468854059b6634147b5fb0467aae3405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468854059b6634147b5fb0467aae3405">&#9670;&nbsp;</a></span>Quadric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Core::Quadric::Quadric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_core_1_1_quadric_1_1_parameters.html">Parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a quadric from the known parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>parameters of the quadric </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9120966a0fb65b0fa85ebe6189bb0a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9120966a0fb65b0fa85ebe6189bb0a2e">&#9670;&nbsp;</a></span>Fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Core::Quadric::Fit </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit the quadric to a data matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the first element of a column major contiguous array of size 3N </td></tr>
    <tr><td class="paramname">N</td><td>the number of columns, or datapoints. </td></tr>
    <tr><td class="paramname">sigma</td><td>The hyper parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31468022b562cd72e0a1d7fbf1ad9c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31468022b562cd72e0a1d7fbf1ad9c07">&#9670;&nbsp;</a></span>FitFast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Core::Quadric::FitFast </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_core_1_1_quadric_1_1_fast_data_store.html">FastDataStore</a> *&#160;</td>
          <td class="paramname"><em>fds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit the quadric to a data matrix given a pre allocated <a class="el" href="struct_core_1_1_quadric_1_1_fast_data_store.html" title="This struct provides an internal datastore for the quadric fitting algorithm, when fitting multiple q...">FastDataStore</a>. In order to execute this method, one would do the following,. </p>
<div class="fragment"><div class="line">FastDataStore *fds = <span class="keyword">new</span> FastDataStore();</div><div class="line"><span class="keywordflow">for</span>(uint32_t k=0; k&lt;NExecs; ++k)</div><div class="line">{</div><div class="line">  quadric[k].FitFast(data[k], N[k], sigma[k], fds);</div><div class="line">}</div></div><!-- fragment --><p> This FitFast method will run without any heap allocations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the first element of a column major contiguous array of size 3N </td></tr>
    <tr><td class="paramname">N</td><td>the number of columns, or datapoints. </td></tr>
    <tr><td class="paramname">sigma</td><td>The hyper parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c2032f964cbb4b61c761488e3915f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2032f964cbb4b61c761488e3915f57">&#9670;&nbsp;</a></span>GetBoundedMeshRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Core::Quadric::GetBoundedMeshRep </td>
          <td>(</td>
          <td class="paramtype">VerticesFaces &amp;&#160;</td>
          <td class="paramname"><em>vf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a bounded mesh representing the quadric. The method takes a canonical surface such as an Ellipsoid and transforms it using the parameters of the quadric. Only an Ellipsoid has been implemented for demonstration purposes. The mesh is then truncated so that the vertices on the input point cloud do not fall outside the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Generate N^2 vertices on the mesh </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the colum major, contigouous, data matrix (with 3NPts elements). </td></tr>
    <tr><td class="paramname">NPts</td><td>The number of points in the data matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb2cc7b7d74b9b1b9d033bc1629702df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2cc7b7d74b9b1b9d033bc1629702df">&#9670;&nbsp;</a></span>GetMeshRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VerticesFaces Core::Quadric::GetMeshRep </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>NPts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mesh representing the quadric. The method takes a canonical surface such as an Ellipsoid and transforms it using the parameters of the quadric. Only an Ellipsoid has been implemented for demonstration purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Generate N^2 vertices on the mesh </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the colum major, contigouous, data matrix (with 3NPts elements). </td></tr>
    <tr><td class="paramname">NPts</td><td>The number of points in the data matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61bd8c7f36790b182523bfc47d8499ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61bd8c7f36790b182523bfc47d8499ea">&#9670;&nbsp;</a></span>GetParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_core_1_1_quadric_1_1_parameters.html">Quadric::Parameters</a> Core::Quadric::GetParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the parameters of the quadric. </p>
<dl class="section return"><dt>Returns</dt><dd>The parameters </dd></dl>

</div>
</div>
<a id="ab5d0f5023937bbc0ce1066d528fa2f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d0f5023937bbc0ce1066d528fa2f2b">&#9670;&nbsp;</a></span>GetPointCloudBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; Core::Quadric::GetPointCloudBounds </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>StartN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of booleans indicating which points on the generated mesh are outside the maximum and minimum point cloud bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StartN</td><td>Generate N^2 vertices on the mesh </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the colum major, contigouous, data matrix (with 3NPts elements). </td></tr>
    <tr><td class="paramname">N</td><td>The number of points in the data matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of bools specifying which vertices are inside the max/min bounds </dd></dl>

</div>
</div>
<a id="a7060ecec0b047e7e3abb419c7f2afb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7060ecec0b047e7e3abb419c7f2afb6a">&#9670;&nbsp;</a></span>GetPrincipleCylinder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VerticesFaces Core::Quadric::GetPrincipleCylinder </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>NPts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return vertices and faces of the quadric, assuming that it is a cylinder. For a quadric cylinder one of the eigenvalues of the parameter A will be zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Generate N^2 vertices on the mesh </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the colum major, contigouous, data matrix (with 3NPts elements). </td></tr>
    <tr><td class="paramname">NPts</td><td>The number of points in the data matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A cylinder mesh </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Core/<a class="el" href="_quadric_8h_source.html">Quadric.h</a></li>
<li>Core/Quadric.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
