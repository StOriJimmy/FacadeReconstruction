#ifndef DATASTORE_HPP_
#define DATASTORE_HPP_

/* ----------------------------------------------------------------------
 * Copyright (C) 2016 Daniel Beale and Luca Benedetti. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ---------------------------------------------------------------------- */

#include "common.hpp"
#include <QtGui>
#include <QtXml>

// typedef for (unique) identifiers of our data structures
typedef unsigned int meshID;
typedef unsigned int rasterID;
typedef unsigned int sketchID;
typedef unsigned int edgeID;
typedef unsigned int surfaceID;

// the kind of mesh we are dealing with
enum MeshKind
{
  POINT_CLOUD, // input point cloud
  POISSON_RECONSTRUCTION, // input poisson cloud
  SURFACE // generated surface
};

// kind of surface
enum SurfaceKind
{
  QUADRIC,
  CYLINDER,
  GTM_INTERPOLATED,
  GTM_ORTHOGONAL,
  NONE
};

// A mesh can either be loaded in input or generated by the system.
// All meshes can be rendered (default with uniform per-mesh color)
// All meshes are assumed living in the reference frame for now.
class Mesh
{
public:
  Mesh();
  ~Mesh();
  bool load(QString filename, QString label);
  bool save(QString filename);
  bool isLoaded();

  // id & pointers
  meshID id;
  MeshKind mesh_kind;
  SurfaceKind surface_kind;
  QString label;

  // payload
  CMesh mesh;
  vcg::GlTrimesh<CMesh> glWrap;
  QColor mesh_color;
  // TODO: texture information
  // GLuint tex_id;

private:
  Mesh(const Mesh &);
  Mesh &operator=(const Mesh &);

  bool loaded;

};

// A raster contains both the color values, the camera calibration,
// and the referenence of the opengl texture
class Raster
{
public:
  Raster();
  ~Raster();
  bool load(QString filename,vcg::Shotf* shot,QString label);
  bool load(QImage image,vcg::Shotf* shot,QString label);
  bool isLoaded();
  //bool from_snapshot() //TODO

  // id & pointers
  rasterID id;
  QList< sketchID > sketches;
  QString label;

  // payload
  QImage image;
  float w; // width for convenience
  float h; // height for convenience
  //cv::Mat image_cv; //TODO add
  GLuint tex_id;
  vcg::Shotf *camera;
  QPixmap thumbnail;

private:
  Raster(const Raster&);
  Raster &operator=(const Raster&);

  bool loaded;
};

// A single point in a sketch
class SketchPoint
{
public:
  SketchPoint();
  SketchPoint(float v);
  SketchPoint( float x, float y, float variance);
  SketchPoint(const SketchPoint &o);
  ~SketchPoint();
  SketchPoint &operator=(const SketchPoint &o);
  SketchPoint & operator+=(const SketchPoint &o);
  SketchPoint & operator*=(const SketchPoint &o);
  SketchPoint & operator-=(const SketchPoint &o);
  SketchPoint & operator/=(const SketchPoint &o);
  SketchPoint & operator+=(float f);
  SketchPoint & operator*=(float f);
  SketchPoint & operator-=(float f);
  SketchPoint & operator/=(float f);
  const SketchPoint operator+(const SketchPoint &o) const;
  const SketchPoint operator*(const SketchPoint &o) const ;
  const SketchPoint operator-(const SketchPoint &o) const ;
  const SketchPoint operator/(const SketchPoint &o) const ;
  const SketchPoint operator+(float f) const;
  const SketchPoint operator*(float f) const;
  const SketchPoint operator-(float f) const ;
  const SketchPoint operator/(float f) const;
  bool operator==(const SketchPoint &o) const;
  bool operator!=(const SketchPoint &o) const;
  float distance_from2(const SketchPoint &o) const;
  float distance_from(const SketchPoint &o) const;
  float length2() const;
  float length() const ;
  SketchPoint& normalize();
  SketchPoint normalized() const;
  float sizePX() const;
  static float variance2sizePX(float variance);

  //payload

  // IMPORTANT: in order to mantain resolution independence and still have values that
  // make sense, x and y are normalized values in [0,1] relative to the image size,
  // while variance is a normalized value in [0,1] that maps, in pixels,
  // to the [MIN_POINT_SIZE,MAX_POINT_SIZE] when considering the original resolution image.
  //
  // this means that if you scale the original resolution of, e.g. 5184 × 3456 px
  // to 1500 x 1000 px, a point with x=0.5, y=0.5, and variance=0.5 will indicate
  // a circle centered in (2592, 1728) with a size of 90.5 pixels in the original image
  // but since the rescaled image is only ~28,93% of the original size, the same values
  // will indicate a circle centered in (750, 500) with a size of 26.19 pixels


  float x; // normalized in reference image width
  float y; // normalizes in reference image height
  float variance; // the width of the brush, normalized in point size interval at original resolution

  static float MIN_POINT_SIZE;
  static float MAX_POINT_SIZE;
};

inline SketchPoint operator* (float s, const SketchPoint& n)
{
  return n*s;
}

// A sketch, that is the collection of 2D points over a raster image
// generated with a user gesture
class Sketch
{
public:
  Sketch(rasterID raster);
  Sketch(const Sketch &o);
  ~Sketch();
  Sketch &operator=(const Sketch &o);

  // id & pointers
  sketchID id;
  rasterID raster;

  // payload
  QList<SketchPoint> points;
  QColor color; // the color identifies the sketches to use when creating an edge
  bool already_used;

private:
  Sketch(); // need a reference raster to be instanced
};

// An edge, that is a collection of 3D points in the space
// generated with SketchesToEdge
class Edge
{
public:
  Edge();
  Edge(const Edge &o);
  Edge &operator=(const Edge &o);

  // id & pointers
  edgeID id;

  // payload
  QList< QVector<float> > points; //Dan, you can use QVector3D here if you prefer

  // mesh format for rendering
  QColor edge_color;
  CMesh mesh;
  vcg::GlTrimesh<CMesh> glWrap;
  bool already_used;

};

// The input parameters for the EdgesToSurface functions
// base class, used for common parameters independent of the surface kind:
class SurfaceInputParams
{
public:
    SurfaceInputParams() : SurfaceType(NONE), SamplingDensity(50) {}

    // user-selectable parameters:
    SurfaceKind SurfaceType; ///< The type of surface

    uint32_t SamplingDensity; ///< The number of points across each dimension
};

// subclass for quadric-specific parameters
class QuadricInputParams : public SurfaceInputParams
{
public:
    QuadricInputParams() : SurfaceInputParams(), sigma(10.0) {}

    double sigma; ///< The prior
};

// subclass for cylinder-specific parameters
class CylinderInputParams : public SurfaceInputParams
{
public:
    CylinderInputParams() : SurfaceInputParams(), sigma(10.0) {}

    double sigma; ///< The prior
};

// subclass for GTM specific parameters
class GTMInputParams : public SurfaceInputParams
{
public:
    GTMInputParams() : SurfaceInputParams(), Degree(3), K(50), MaxIter(20), lambda(5.0) {}

    uint32_t Degree;  ///< The degree of the polynomial
    uint32_t K;       ///< The number of components
    uint32_t MaxIter; ///< The maximum number of iterations
    double lambda;    ///< The uncertainty
};

// the datastore contains all the data in the scene
// it follows a singleton design pattern
class DataStore
{
public:
  // the actual containers
  QMap< meshID, Mesh* > meshes;
  QMap< rasterID, Raster* > rasters;
  QMap< sketchID, Sketch* > sketches;
  QMap< edgeID, Edge* > edges;

  // the parameters for the various kinds of surfaces
  // TODO DAN sensible default values
  QuadricInputParams *quadric_input_params;
  CylinderInputParams *cylinder_input_params;
  GTMInputParams *gtm_input_params;

  // pointers to the base meshes
  meshID point_cloud;
  meshID poisson_input;

  // currently selected raster
  rasterID current_raster;

  QString mlp_filename;

  static DataStore* data(); // reference to the singleton instance

  bool load_MLP(QString filename);
  bool isLoaded(); //return true if the MLP file has been loaded
  bool save_MLP(QString filename);

private:

  bool loaded;

  // singleton stuff
  DataStore();
  DataStore(const DataStore&);
  DataStore& operator=(const DataStore &);
  static DataStore *instance;
};

#endif /* DATASTORE */
