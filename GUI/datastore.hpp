#ifndef DATASTORE_HPP_
#define DATASTORE_HPP_

/* ----------------------------------------------------------------------
 * Copyright (C) 2016 Daniel Beale and Luca Benedetti. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ---------------------------------------------------------------------- */

#include "common.hpp"
#include <QtGui>
#include <QtXml>

// typedef for (unique) identifiers of our data structures
typedef unsigned int meshID;
typedef unsigned int rasterID;
typedef unsigned int sketchID;
typedef unsigned int edgeID;
typedef unsigned int surfaceID;

/**
 * \brief An enumeration of the kinds of mesh we are dealing with
 */
enum MeshKind
{
  POINT_CLOUD, // input point cloud
  POISSON_RECONSTRUCTION, // input poisson cloud
  SURFACE // generated surface
};

/**
 * @brief An enumeration of the kinds of surface we are dealing with
 */
enum SurfaceKind
{
  QUADRIC,
  CYLINDER,
  GTM_INTERPOLATED,
  GTM_ORTHOGONAL,
  NONE
};

/**
  * \brief A wrapper for the vcg mesh objects.
  * A mesh can either be loaded in input or generated by the system.
  * All meshes can be rendered (default with uniform per-mesh color)
  * All meshes are assumed to be living in the reference frame for now.
  * @todo: texture information. Add member variable 'GLuint tex_id'.
  */
class Mesh
{
public:
    /**
     * @brief Construct an empty mesh
     */
    Mesh();

    /**
      * \brief Detroy the mesh object
      */
    ~Mesh();

    /**
     * @brief load a mesh from file. Currently only the Stanford ply file is supported.
     * @param filename The path to the file
     * @param label The label for the mesh
     * @return True on success
     */
    bool load(QString filename, QString label);

    /**
     * @brief Save the mesh to disk. Currently only the Stanford ply file is supported.
     * @param filename The path to the file.
     * @return
     */
    bool save(QString filename);

    /**
     * @brief Return true if a mesh has been loaded.
     * @return True if the mesh is loaded.
     */
    bool isLoaded();

    // id & pointers
    meshID id;                    ///< The mesh id
    MeshKind mesh_kind;           ///< The type of mesh
    SurfaceKind surface_kind;     ///< The type of surface
    QString label;                ///< The mesh label

    // payload
    CMesh mesh;                   ///< The vcg mesh object
    vcg::GlTrimesh<CMesh> glWrap; ///< An opengl wrapper for the vcg mesh
    QColor mesh_color;            ///< The colour of the mesh

private:
    Mesh(const Mesh &);             ///< \brief A private copy constructor
    Mesh &operator=(const Mesh &);  ///< \brief A private assignment operator

    bool loaded;                    ///< True if the mesh has been loaded.
};


/**
 * @brief The Raster class.
 * A raster contains both the color values, the camera calibration,
 * and the referenence of the opengl texture.
 * @todo Create a 'from_snapshot' method to load the raster.
 * @todo Add a cv::Mat image to the member variables
 */
class Raster
{
public:
    /**
     * @brief Construct an empty raster.
     */
    Raster();

    /**
      * \brief Destroy the raster object
      */
    ~Raster();

    /**
     * @brief Load a raster from file
     * @param filename The path to the image file
     * @param shot The camera shot to load the camera information in to.
     * @param label A label for the raster
     * @return True on success
     */
    bool load(QString filename,vcg::Shotf* shot,QString label);

    /**
     * @brief Create a raster from a QImage object
     * @param image The QImage to create the raster from.
     * @param shot The camera shot to load the camera information in to.
     * @param label The label for the raster
     * @return True on success
     */
    bool load(QImage image,vcg::Shotf* shot,QString label);

    /**
     * @brief Return true if the raster has been loaded
     * @return True if the raster has loaded
     */
    bool isLoaded();

    rasterID id;                    ///< The raster id
    QList< sketchID > sketches;     ///< A list of user drawn sketches
    QString label;                  ///< The raster label

    QImage image;                   ///< The raster image
    float w;                        ///< The raster width (for convenience)
    float h;                        ///< The raster height (for convenience)

    GLuint tex_id;                  ///< The opengl texture id
    vcg::Shotf *camera;             ///< The camera information
    QPixmap thumbnail;              ///< A thumbnail pixmap

private:
    Raster(const Raster&);             ///< \brief A private copy constructor
    Raster &operator=(const Raster&);  ///< \brief A private assignment operator

    bool loaded;                    ///< True if the raster has been loaded.
};

//
/**
 * @brief A single point in a sketch.
 *
 * IMPORTANT: in order to mantain resolution independence and still have values that
 * make sense, x and y are normalized values in [0,1] relative to the image size,
 * while variance is a normalized value in [0,1] that maps, in pixels,
 * to the [MIN_POINT_SIZE,MAX_POINT_SIZE] when considering the original resolution image.
 *
 * This means that if you scale the original resolution of, e.g. 5184 × 3456 px
 * to 1500 x 1000 px, a point with x=0.5, y=0.5, and variance=0.5 will indicate
 * a circle centered in (2592, 1728) with a size of 90.5 pixels in the original image
 * but since the rescaled image is only ~28,93% of the original size, the same values
 * will indicate a circle centered in (750, 500) with a size of 26.19 pixels
 */
class SketchPoint
{
public:
    /**
     * @brief Construct an empty SketchPoint
     */
    SketchPoint();

    /**
     * @brief Construct a SketchPoint with a variance
     * @param v The variance
     */
    SketchPoint(float v);

    /**
     * @brief Construct a SketchPoint with a position and variance
     * @param x The x position
     * @param y The y posision
     * @param variance The variance
     */
    SketchPoint( float x, float y, float variance);

    /**
     * @brief Copy construct the SketchPoint
     * @param o
     */
    SketchPoint(const SketchPoint &o);

    /**
      * \brief Destroy the SketchPoint object
      */
    ~SketchPoint();
    SketchPoint &operator=(const SketchPoint &o);               ///< \brief The assigment operator
    SketchPoint & operator+=(const SketchPoint &o);             ///< \brief Add SketchPoints
    SketchPoint & operator*=(const SketchPoint &o);             ///< \brief Multiply SketchPoints
    SketchPoint & operator-=(const SketchPoint &o);             ///< \brief Negate SketchPoints
    SketchPoint & operator/=(const SketchPoint &o);             ///< \brief Divide SketchPoints
    SketchPoint & operator+=(float f);                          ///< \brief Add a SketchPoint to a float
    SketchPoint & operator*=(float f);                          ///< \brief Multiply a SketchPoint by a float
    SketchPoint & operator-=(float f);                          ///< \brief Negate a SketchPoint from a float
    SketchPoint & operator/=(float f);                          ///< \brief Divide a SketchPoint by a float
    const SketchPoint operator+(const SketchPoint &o) const;    ///< \brief The assigment operator
    const SketchPoint operator*(const SketchPoint &o) const ;   ///< \brief Add SketchPoints
    const SketchPoint operator-(const SketchPoint &o) const ;   ///< \brief Negate SketchPoints
    const SketchPoint operator/(const SketchPoint &o) const ;   ///< \brief Divide SketchPoints
    const SketchPoint operator+(float f) const;                 ///< \brief Add a SketchPoint to a float (const)
    const SketchPoint operator*(float f) const;                 ///< \brief Multiply a SketchPoint by a float (const)
    const SketchPoint operator-(float f) const ;                ///< \brief Negate a SketchPoint from a float (const)
    const SketchPoint operator/(float f) const;                 ///< \brief Divide a SketchPoint from a float (const)
    bool operator==(const SketchPoint &o) const;                ///< \brief Comparison operator for SketchPoints
    bool operator!=(const SketchPoint &o) const;                ///< \brief Negated comparison operator for SketchPoints
    float distance_from2(const SketchPoint &o) const;           ///< \brief Return the squared Euclidean distance from 'this' to the input SketchPoint
    float distance_from(const SketchPoint &o) const;            ///< \brief Return the Euclidean distance from 'this' to the input SketchPoint
    float length2() const;                                      ///< \brief Return the squared Euclidean norm of this SketchPoint
    float length() const ;                                      ///< \brief Return the Euclidean norm of 'this' SketchPoint.
    SketchPoint& normalize();                                   ///< \brief Divide 'this' SketchPoint' by its length. Return a reference to 'this'.
    SketchPoint normalized() const;                             ///< \brief Return 'this' SketchPoint normalized
    float sizePX() const;                                       ///< \brief Return the  size in pixels at original resolution
    static float variance2sizePX(float variance);               ///< \brief Return the  size in pixels at original resolution

    //payload

    float x;                        ///< The x position normalized in reference image width
    float y;                        ///< The y position normalized in reference image height
    float variance;                 ///< The width of the brush, normalized in point size interval at original resolution

    static float MIN_POINT_SIZE;    ///< The minimum point size in pixels
    static float MAX_POINT_SIZE;    ///< The maximum point size in pixels
};

/**
 * @brief operator *.
 * Multiply a SketchPoint by a scalar
 * @param s The scalar
 * @param n The SketchPoint
 * @return
 */
inline SketchPoint operator* (float s, const SketchPoint& n)
{
  return n*s;
}

/**
 * @brief The Sketch class.
 * A sketch, that is the collection of 2D points over a raster image
 * generated with a user gesture
 */
class Sketch
{
public:
    /**
     * @brief Construct a Sketch form a rasterID.
     * @param raster The rasterID
     */
    Sketch(rasterID raster);

    /**
     * @brief Copy construct a Sketch
     * @param o
     */
    Sketch(const Sketch &o);

    /**
      * \brief Destroy the Sketch
      */
    ~Sketch();

    /**
     * @brief The assigment operator for the Sketch
     */
    Sketch &operator=(const Sketch &o);

    // id & pointers
    sketchID id;                ///< The Sketch id
    rasterID raster;            ///< The raster id

    // payload
    QList<SketchPoint> points;  ///< A QList of SketchPoints
    QColor color;               ///< The colour. The color identifies the sketches to use when creating an edge
    bool already_used;          ///< True if the Sketch is being used

private:
    Sketch();                   ///< Require a reference raster to be instanced
};


/**
 * @brief The Edge class.
 * An edge, that is a collection of 3D points in the space
 * generated with SketchesToEdge.
 */
class Edge
{
public:
    /**
     * @brief Construct an empty Edge
     */
    Edge();

    /**
     * @brief Copy construct and Edge
     */
    Edge(const Edge &o);

    /**
     * @brief Assign an edge
     */
    Edge &operator=(const Edge &o);

    // id & pointers
    edgeID id;                          ///< The edge id

    // payload
    QList< QVector<float> > points;     ///< A QList of 3D vectors, representing the positions of the edge.

    // mesh format for rendering
    QColor edge_color;                  ///< The edge colour
    CMesh mesh;                         ///< The mesh
    vcg::GlTrimesh<CMesh> glWrap;       ///< A gl wrapper for the mesh
    bool already_used;                  ///< True if the edge is already used
};

//
/**
 * @brief The SurfaceInputParams class.
 * The input parameters for the EdgesToSurface functions
 * base class, used for common parameters independent of the surface kind:
 */
class SurfaceInputParams
{
public:
    /**
     * @brief Construct the default surface input parameters
     */
    SurfaceInputParams() : SurfaceType(NONE), SamplingDensity(50) {}

    // user-selectable parameters:
    SurfaceKind SurfaceType;    ///< The type of surface
    uint32_t SamplingDensity;   ///< The number of points across each dimension
};

/**
 * @brief Subclass for quadric-specific parameters
 */
class QuadricInputParams : public SurfaceInputParams
{
public:
    /**
     * @brief Construct the default quadric parameters.
     */
    QuadricInputParams() : SurfaceInputParams(), sigma(10.0) {}

    double sigma; ///< The variance prior
};

/**
 * @brief Subclass for cylinder-specific parameters
 */
class CylinderInputParams : public SurfaceInputParams
{
public:
    /**
     * @brief Construct the default cylinder parameters.
     */
    CylinderInputParams() : SurfaceInputParams(), sigma(10.0) {}

    double sigma; ///< The variance prior
};

/**
 * @brief Subclass for GTM specific parameters
 */
class GTMInputParams : public SurfaceInputParams
{
public:
    /**
     * @brief Construct the default GTM parameters
     */
    GTMInputParams() : SurfaceInputParams(), Degree(3), K(50), MaxIter(20), lambda(5.0) {}

    uint32_t Degree;  ///< The degree of the polynomial
    uint32_t K;       ///< The number of components
    uint32_t MaxIter; ///< The maximum number of iterations
    double lambda;    ///< The uncertainty
};

/**
 * @brief The DataStore class.
 * The datastore contains all the data in the scene
 * it follows a singleton design pattern
 */
class DataStore
{
public:
  // the actual containers
  QMap< meshID, Mesh* > meshes;                 ///< A QMap from meshID to Mesh
  QMap< rasterID, Raster* > rasters;            ///< A QMap from rasterID to Raster
  QMap< sketchID, Sketch* > sketches;           ///< A QMap from sketchID to Sketch
  QMap< edgeID, Edge* > edges;                  ///< A Qmap from edgeID to Edge

  QuadricInputParams *quadric_input_params;     ///< The input parameters for the quadric
  CylinderInputParams *cylinder_input_params;   ///< The input parameters for the cylinder
  GTMInputParams *gtm_input_params;             ///< THe input parameters for the GTM

  // pointers to the base meshes
  meshID point_cloud;                           ///< The mesh id for the point cloud
  meshID poisson_input;                         ///< The mesh id for the poisson input

  // currently selected raster
  rasterID current_raster;                      ///< The raster id for the current raster

  QString mlp_filename;                         ///< The path of the mlp file

  static DataStore* data();                     ///< \brief Return a reference to the singleton instance

  /**
   * @brief Load the data from an MLP file
   * @param filename The path to the file
   * @return True if loaded.
   */
  bool load_MLP(QString filename);

  /**
   * @brief Return true if the MLP file has been loaded
   * @return True on load
   */
  bool isLoaded();

  /**
   * @brief Save the MLP file to disk
   * @param filename The path to save the MLP file to
   * @return
   */
  bool save_MLP(QString filename);

private:

  bool loaded;                              ///< True when the data has been loaded

  // singleton stuff
  DataStore();                              ///< \brief Private constructor to ensure singleton
  DataStore(const DataStore&);              ///< \brief Private copy constructor to ensure singleton
  DataStore& operator=(const DataStore &);  ///< \brief Private assignment operator to ensure singleton

  static DataStore *instance;               ///< The datastore instance.
};

#endif /* DATASTORE */
